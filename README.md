# SCISSORS

This package allows the reclustering of single cell clusters based on the identification of the highly variable genes that are unique to each cluster. Here we'll briefly describe the workflow on the classic PBMC3k dataset from 10X Genomics.

# Installation

`SCISSORS` can be installed from this repository like so:

```{r}
remotes::install_github("jr-leary7/SCISSORS")
```

# Getting Started

Here's a basic tutorial on how to get `SCISSORS` up and running (and finding cool cell subgroups for you!).

## Libraries

First, we load the necessary libraries, `Seurat` to contain our analyses and `SeuratData` for our example dataset.

```{r}
library(Seurat)
library(SeuratData)
```

## Preprocessing

Next, we use the `PrepareData()` function to pre-process our data. This function calculates the percentage of mitochondrial DNA for each cell and uses `SCTransform` to select highly variable genes, normalize and scale the counts, and regress out the effect of the percentage of mitochondrial DNA. It then runs PCA, chooses an appropriate number of principal components using a cutoff value for the cumulative proportion of variance explained, and then performs t-SNE using the principal component matrix as an initialization for the embedding. Finally, we create a SNN graph using the approximation *k* \~ sqrt(*N*) and generate a preliminary rough clustering of our cells using Louvain modularity optimization. Basically, the function performs all the necessary pre-processing steps commonly used in `Seurat`.

```{r}
pbmc <- SeuratData::LoadData("pbmc3k")
pbmc <- PrepareData(seurat.object = pbmc3k, 
                    n.variable.genes = 4000, 
                    n.PC = 15, 
                    which.dim.reduc = "umap", 
                    initial.resolution = .4, 
                    random.seed = 629)
```

If you want to get the silhouette score for each cell use the following snippet. To get just the mean value for each cluster, set `avg = TRUE`. 

```{r}
sil_score_df <- ComputeSilhouetteScores(pbmc, avg = FALSE)
```

## Reclustering

The `ReclusterCells()` function performs the actual subpopulation-detection analysis, which is based on tuning the parameters of the Louvain modularity optimization function with the goal of maximizing the mean silhouette score of a given set of parameters. In this case, after investigating the preliminary clustering results (see the PBMC vignette for details), we decide to identify subpopulations in clusters 0 and 2, which we think contain T cells. The function returns a `Seurat` object with re-normalized counts, re-identified highly variable genes, re-computed dimension reductions, and a clustering generated by the set of parameters *k* (nearest-neighbors) and *r* (resolution) that gave the highest mean silhouette score. 

```{r}
t_reclust <- ReclusterCells(pbmc, 
                            which.clust = list(0, 2), 
                            merge.clusters = TRUE, 
                            n.HVG = 4000, 
                            n.PC = 15, 
                            k.vals = c(30, 40, 50), 
                            resolution.vals = c(.3, .4, .5), 
                            redo.embedding = TRUE, 
                            random.seed = 629)
```

The user can decide how large of a parameter set to provide; since every combination of parameters is tested, larger parameter sets will lead to longer compute times but may give more accurate results. 

## Identifying Marker Genes

Once a satisfactory reclustering has been generated, it's common practice to identify marker genes with which to annotate the clusters. We provide a function, `FindSpecificMarkers()`, which identifies marker genes for each cluster under the constraint that those markers are not highly expressed in any of the other clusters. This is done by simply identifying marker genes for each cluster, and then filtering those markers on a per-cluster basis by genes that are expressed above a percentile cutoff in any of the other clusters. 

```{r}
t_markers <- FindSpecificMarkers(t_reclust, ident.use = "seurat_clusters", perc.cutoff = 0.95)
```

## Re-integrating Subclusters

Lastly, once the subclusters have been identified and annotate we can add their identities back to the original `Seurat` object like so:

```{r}
pbmc <- IntegrateSubclusters(original.object = pbmc, 
                             reclust.results = list(t_reclust))
```

The above function also works for multiple reclustering results; just provide the list of subpopulation `Seurat` objects to the `reclust.results` argument. 

# Contact Information

This package is based on the ideas of Dr. Xianlu Peng (Research Assistant Professor in Dept. of Pharmacology, Lineberger Comprehensive Cancer Center, UNC Chapel Hill). The code is written and maintained by Jack Leary (Lineberger Comprehensive Cancer Center, University of Florida Department of Biostatistics). Jack can be reached on GitHub as well as at [jrleary\@live.unc.edu](mailto:jrleary@live.unc.edu) for any questions, issues, or bugs.
