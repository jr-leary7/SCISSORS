# SCISSORS

This package allows the reclustering of single cell clusters based on the identification of the highly variable genes that are unique to each cluster. Here we'll briefly describe the workflow on the classic PBMC3k dataset from 10X Genomics.

# Installation

`SCISSORS` can be installed from this repository like so:

```{r}
remotes::install_github("jr-leary7/SCISSORS")
```

# Getting Started

Here's a basic tutorial on how to get `SCISSORS` up and running (and finding cool cell subgroups for you!).

## Libraries

First, we load the necessary libraries, including `Seurat` for data structures and `SeuratData` for our example dataset.

```{r}
library(Seurat)
library(SCISSORS)
library(SeuratData)
```

## Parallelism 

Both main functions in `SCISSORS` (`PrepareData()` and `ReclusterCells()`) support parallel processing in order to speed up operations. The `future` package is used to parallelize the `Seurat` processing code, and `foreach` is used for the main reclustering loop. While the `foreach` loop doesn't need any extra care to be used, `future` can be tricky due to its default memory limits. If you're going to use parallel processing, make sure to add this line of code at the beginning of your processing code. It increases the size of objects that can be exported to each parallel worker - but be careful to not exceed to amount of free memory on your system. Replace the `1000` with the number of MB you'd like to be able to export, e.g., `10000` is equivalent to 10GB. 

```{r}
options(future.globals.maxSize = 1000 * 1024^2)   # 1GB per worker 
options(future.globals.maxSize = 10000 * 1024^2)  # 10GB per worker 
```

## Preprocessing

Next, we use the `PrepareData()` function to pre-process our data. This function can calculate the percentage of mitochondrial DNA for each cell, select highly variable genes, normalize and scale the counts, and regress out the effect of the percentage of mitochondrial DNA as well as cell cycle effects. It then runs PCA, chooses an appropriate number of principal components using a cutoff value for the cumulative proportion of variance explained, and then performs non-linear dimension reduction using the principal component matrix as an initialization various embeddings. Finally, we create a SNN graph using the approximation *k* \~ sqrt(*n*) and generate a preliminary rough clustering of our cells using Louvain modularity optimization. Essentially, the function performs all the usual pre-processing steps commonly used in `Seurat`.

```{r}
pbmc <- SeuratData::LoadData("pbmc3k")
pbmc <- PrepareData(seurat.object = pbmc3k, 
                    n.variable.genes = 4000, 
                    n.PC = 15, 
                    which.dim.reduc = "umap", 
                    initial.resolution = .4, 
                    random.seed = 629)
```

If you want to get the silhouette score for each cell use the following snippet. To get just the mean value for each cluster, set `avg = TRUE`. 

```{r}
sil_score_df <- ComputeSilhouetteScores(pbmc, avg = FALSE)
```

## Reclustering

The `ReclusterCells()` function performs the actual subpopulation-detection analysis, which is based on tuning the parameters of the Louvain modularity optimization function with the goal of maximizing the mean silhouette score of a given set of parameters. In this case, after investigating the preliminary clustering results (see the PBMC vignette for details), we decide to identify subpopulations in clusters 0 and 2, which we think contain T cells. The function returns a `Seurat` object with re-normalized counts, re-identified highly variable genes, re-computed dimension reductions, and a clustering generated by the set of parameters *k* (nearest-neighbors) and *r* (resolution) that gave the highest mean silhouette score. 

```{r}
t_reclust <- ReclusterCells(pbmc, 
                            which.clust = list(0, 2), 
                            merge.clusters = TRUE, 
                            n.HVG = 4000, 
                            n.PC = 15, 
                            k.vals = c(30, 40, 50), 
                            resolution.vals = c(.3, .4, .5), 
                            redo.embedding = TRUE, 
                            random.seed = 629)
```

The user can decide how large of a parameter set to provide; since every combination of parameters is tested, larger parameter sets will lead to longer compute times but may give more accurate results. 

## Identifying Marker Genes

Once a satisfactory reclustering has been generated, it's common practice to identify marker genes with which to annotate the clusters. We provide a function, `FindSpecificMarkers()`, which identifies marker genes for each cluster under the constraint that those markers are not highly expressed in any of the other clusters. This is done by simply identifying marker genes for each cluster, and then filtering those markers on a per-cluster basis by genes that are expressed above a percentile cutoff in any of the other clusters. 

```{r}
t_markers <- FindSpecificMarkers(t_reclust, ident.use = "seurat_clusters", perc.cutoff = 0.95)
```

## Re-integrating Subclusters

Lastly, once the subclusters have been identified and annotate we can add their identities back to the original `Seurat` object like so:

```{r}
pbmc <- IntegrateSubclusters(original.object = pbmc, reclust.results = t_reclust)
```

The above function also works for multiple reclustering results; just provide the list of subpopulation `Seurat` objects to the `reclust.results` argument. 

# Contact Information

This package is based on the ideas of Dr. Xianlu Peng (Research Assistant Professor in Dept. of Pharmacology, Lineberger Comprehensive Cancer Center, UNC Chapel Hill). The code is written and maintained by Jack Leary (Lineberger Comprehensive Cancer Center, University of Florida Department of Biostatistics). Jack can be reached on GitHub as well as at [jrleary\@live.unc.edu](mailto:jrleary@live.unc.edu) for any questions, issues, or bugs.
