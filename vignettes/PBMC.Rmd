---
title: "PBMC Analysis using SCISSORS"
subtitle: "Jack Leary"
author: 
  - "University of North Carolina at Chapel Hill - Lineberger Comprehensive Cancer Center"
  - "University of Florida - Department of Biostatistics"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: paper
    highlight: tango
    df_print: kable
    toc: true
    toc_float: true
    code_folding: show
    code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      fig.align = "center")
reticulate::use_virtualenv("~/Desktop/Python/science/venv/", required = TRUE)
set.seed(629)
```

# Introduction

This document will serve as a tutorial for using `SCISSORS`, with the added functionality of detailing exactly how the PBMC3k dataset figures presented in our manuscript were generated. We'll start from a 10X counts matrix and end with fully annotated cell clusters. In addition to R, in order to run all the code in this document you'll need a Python 3 installation with `openTSNE` and all its dependencies installed.

# Libraries

## R

```{r}
library(dplyr)       # tidy data manipulation
library(Seurat)      # single cell infrastructure
library(ggplot2)     # plots
library(SCISSORS)    # our package 
library(paletteer)   # advanced colors
library(reticulate)  # Python interface
library(SeuratData)  # PBMC3k dataset
```

## Python

```{python}
import numpy as np
from openTSNE import TSNEEmbedding
from openTSNE import initialization
from openTSNE.affinity import Multiscale
from openTSNE.affinity import PerplexityBasedNN
```

# Data

We load a scRNA-seq dataset provided by 10X Genomics that consists of 2,700 peripheral blood mononuclear cells (PBMCs) from a healthy donor.

```{r}
pbmc <- LoadData("pbmc3k")
```

# Preprocessing

Here we use `PrepareData()` to normalize expression & select highly variable genes through `sctransform`, run PCA & t-SNE. and cluster our cells. We utilize 15 principal components even though [the Satija Lab vignette]((https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html)) used 10, as we use `sctransform` normalization, which does a better job of retaining biological heterogeneity through normalization than standard log-normalization.

```{r, warning=FALSE, message=FALSE}
pbmc <- PrepareData(pbmc, 
                    n.HVG = 4000, 
                    regress.cc = FALSE, 
                    regress.mt = FALSE, 
                    n.PC = 15, 
                    which.dim.reduc = "tsne",
                    initial.resolution = .4, 
                    random.seed = 629)
```

We see clear visual evidence of subclusters. 

```{r}
p0 <- DimPlot(pbmc, cols = paletteer_d("ggthemes::Classic_20")) + 
      labs(x = "t-SNE 1", y = "t-SNE 2") + 
      theme_yehlab() + 
      guides(color = guide_legend(nrow = 1, override.aes = list(size = 3)))
p0
```

## Fit-SNE

We'll also run the Fast Fourier Transform-accelerated version of t-SNE as implemented in the Python library `openTSNE`. First we'll need to get our PC matrix into a form accessible by our Python interpreter.

```{r}
pc_mat <- Embeddings(pbmc, reduction = "pca")
```

```{python}
# import PC matrix
pc_mat = np.array(r.pc_mat)
# run Fit-SNE w/ multiscale kernel
init = initialization.pca(pc_mat, random_state=629)
affin_anneal = PerplexityBasedNN(pc_mat, perplexity=50, metric='cosine', random_state=629)
tsne = TSNEEmbedding(init, affin_anneal, negative_gradient_method='fft')
embed1 = tsne.optimize(n_iter=250, exaggeration=10, momentum=0.6)
embed2 = embed1.optimize(n_iter=750, exaggeration=1, momentum=0.8)
affin_anneal.set_perplexity(20)
embed3 = embed2.optimize(n_iter=50, exaggeration=1, momentum=0.8)
embed4 = embed3.optimize(n_iter=350)
```

Now we pull the results back into R, and save them in our `Seurat` object. We save the original embedding (made using the default Barnes-Hut approximate t-SNE implementation) in `pbmc@reduction$bh_tsne` - we need to do this in order to make the Fit-SNE embedding the default embedding that will be retrieved in calls to functions such as `DimPlot()` or `FeaturePlot()`. 

```{r}
embed <- as.matrix(py$embed4)
rownames(embed) <- colnames(pbmc)
colnames(embed) <- c("Fit-SNE_1", "Fit-SNE_2")
pbmc@reductions$bh_tsne <- pbmc@reductions$tsne
pbmc@reductions$tsne <- CreateDimReducObject(embeddings = embed, 
                                             key = "FitSNE_", 
                                             assay = "SCT", 
                                             global = TRUE)
```

Visualizing the results shows pretty much the same global structure as with the default t-SNE implementation, albeit rotated a bit, but I like that Fit-SNE's clusters are a bit denser, so we'll use Fit-SNE going forward.

```{r}
p1 <- DimPlot(pbmc, cols = paletteer_d("ggthemes::Classic_20")) + 
      labs(x = "Fit-SNE 1", y = "Fit-SNE 2") + 
      theme_yehlab() + 
      guides(color = guide_legend(nrow = 1, override.aes = list(size = 3)))
p1
```

## Broad Cell Types

Next we'll run a differential expression test in order to assign general labels to our clusters. These identities will help guide our reclustering. 

```{r}
pbmc_de <- FindAllMarkers(pbmc, 
                          logfc.threshold = .5, 
                          test.use = "wilcox", 
                          only.pos = TRUE, 
                          random.seed = 629, 
                          verbose = FALSE)
pbmc_de %>% 
  group_by(cluster) %>% 
  top_n(n = 5, wt = avg_log2FC) -> top_de
```

From the top 5 differentially expressed genes for each cluster, we can deduce some basic cluster identities. Clusters 0, 2, and 3 look like T cells. Clusters 1 and 5 appear to be monocytes. Cluster 4 strongly expresses B cell markers. Lastly, Cluster 6 is pretty clearly identifiable as being composed of NK cells. When we recluster our cells, we'll keep the biological context of these broad cell types in mind. 

```{r}
p2 <- DotPlot(pbmc, features = unique(top_de$gene)) + 
      scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) +
      labs(color = "Scaled Mean Expression", size = "% Expressed", x = "Marker Genes", y = "Cluster") + 
      theme(axis.text.x = element_text(angle = 45, size = 7, vjust = 0.65), 
            legend.position = "bottom", legend.justification = "center", 
            panel.border = element_rect(fill = NA, size = 1, color = "black"), 
            axis.line = element_blank()) + 
      guides(color = guide_colorbar(title.position = "top", barwidth = unit(6, units = "cm"), title.hjust = 0.5), 
             size = guide_legend(title.position = "top", title.hjust = 0.5))
p2
```

# Reclustering

We'll run SCISSORS on the monocytes & T cells; i.e. on clusters 1 & 4 and 0 & 2. We use slightly different possible parameter sets as the T cell object is much larger than the monocyte object. 

```{r, warning=FALSE, message=FALSE, results='hold'}
mono_reclust <- ReclusterCells(pbmc, 
                               which.clust = list(1, 4), 
                               merge.clusters = TRUE, 
                               n.HVG = 4000,
                               n.PC = 15, 
                               k.vals = c(10, 15, 20, 25), 
                               resolution.vals = c(.3, .4, .5), 
                               redo.embedding = TRUE, 
                               random.seed = 629)
t_reclust <- ReclusterCells(pbmc, 
                            which.clust = list(0, 2), 
                            merge.clusters = TRUE, 
                            n.HVG = 4000, 
                            n.PC = 15, 
                            k.vals = c(30, 40, 50), 
                            resolution.vals = c(.3, .4, .5), 
                            redo.embedding = TRUE, 
                            random.seed = 629)
DimPlot(mono_reclust)
```

Now we'll run Fit-SNE on each of the reclustered objects for consistencies sake. First we'll need to create variables containing the PC matrices and send them to Python. 

```{r}
pc_mono <- Embeddings(mono_reclust, reduction = "pca")
pc_t <- Embeddings(t_reclust, reduction = "pca")
```

We run Fit-SNE. 

```{python}
# import PC matrices
pc_mono = np.array(r.pc_mono)
pc_t = np.array(r.pc_t)

# run Fit-SNE w/ perplexity annealing - Monocytes
init_mono = initialization.pca(pc_mono, random_state=629)
affin_anneal_mono = PerplexityBasedNN(pc_mono, perplexity=50, metric='cosine', random_state=629)
tsne_mono = TSNEEmbedding(init_mono, affin_anneal_mono, negative_gradient_method='fft')
embed1_mono = tsne_mono.optimize(n_iter=250, exaggeration=12, momentum=0.6)
embed2_mono = embed1_mono.optimize(n_iter=950, exaggeration=1, momentum=0.8)

# run Fit-SNE w/ perplexity annealing - T cells
init_t = initialization.pca(pc_t, random_state=629)
affin_anneal_t = PerplexityBasedNN(pc_t, perplexity=50, metric='cosine', random_state=629)
tsne_t = TSNEEmbedding(init_t, affin_anneal_t, negative_gradient_method='fft')
embed1_t = tsne_t.optimize(n_iter=250, exaggeration=12, momentum=0.6)
embed2_t = embed1_t.optimize(n_iter=950, exaggeration=1, momentum=0.8)
```

Now we bring the results back in to R.

```{r}
embed_mono <- as.matrix(py$embed2_mono)
rownames(embed_mono) <- colnames(mono_reclust)
mono_reclust@reductions$bh_tsne <- mono_reclust@reductions$tsne
mono_reclust@reductions$tsne <- CreateDimReducObject(embeddings = embed_mono, 
                                                     key = "FitSNE_",
                                                     assay = "SCT", 
                                                     global = TRUE)
embed_t <- as.matrix(py$embed2_t)
rownames(embed_t) <- colnames(t_reclust)
t_reclust@reductions$bh_tsne <- t_reclust@reductions$tsne
t_reclust@reductions$tsne <- CreateDimReducObject(embeddings = embed_t,
                                                  key = "FitSNE_",
                                                  assay = "SCT",
                                                  global = TRUE)
```

Here's what our reclusterings look like. There's clear visual separation between the main clusters and the subgroups we've discovered using `SCISSORS`.

```{r}
p3 <- DimPlot(mono_reclust, cols = paletteer_d("ggsci::nrc_npg")) + 
      labs(x = "Fit-SNE 1", y = "Fit-SNE 2") + 
      theme_yehlab() + 
      guides(color = guide_legend(nrow = 1, override.aes = list(size = 3)))
p4 <- DimPlot(t_reclust, cols = paletteer_d("ggsci::nrc_npg")) + 
      labs(x = "Fit-SNE 1", y = "Fit-SNE 2") + 
      theme_yehlab() + 
      guides(color = guide_legend(nrow = 1, override.aes = list(size = 3)))
p3
p4
```

Next, we'll reintegrate our new clusters into our original `Seurat` object - this requires some finagling as `Seurat` is a bit weird with how it stores cell-level metadata. Since we had six clusters originally, and we discovered six new subclusters, we'll end up with twelve total clusters.

```{r, message=FALSE}
pbmc <- IntegrateSubclusters(original.object = pbmc, 
                             reclust.results = list(mono_reclust, t_reclust))
p5 <- DimPlot(pbmc, cols = paletteer_d("ggthemes::Classic_20")) + 
      labs(x = "Fit-SNE 1", y = "Fit-SNE 2") + 
      theme_yehlab() + 
      guides(color = guide_legend(nrow = 1, override.aes = list(size = 3)))
p1
p5
```

# Identify Cell Types

Now that we've determined our subpopulations, we can assign cell types to each cluster using the marker genes provided in [the Satija Lab's PBMC3k vignette](https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html), as well as other canonical markers.

## CD4+ T Cells

We can quickly identify cluster 0 as the naive CD4+ T cells, and cluster 6 as the memory CD4+ population.

```{r}
p6 <- FeaturePlot(pbmc, features = "IL7R") + 
      scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
      theme_yehlab() + 
      NoLegend() + 
      theme(axis.title = element_blank())
p7 <- FeaturePlot(pbmc, features = "CCR7") + 
      scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
      theme_yehlab()  + 
      NoLegend() + 
      theme(axis.title = element_blank())
p8 <- FeaturePlot(pbmc, features = "S100A4") + 
      scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
      theme_yehlab() + 
      NoLegend() + 
      theme(axis.title = element_blank())
(p6 | p7 | p8) / p5
```

## CD14+ Monocytes

Cluster 1 clearly houses our CD14+ monocytes.

```{r}
p12 <- FeaturePlot(pbmc, features = "CD14") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p13 <- FeaturePlot(pbmc, features = "LYZ") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
(p12 | p13) / p5
```

## FCGR3A+ Monocytes

The FCGR3A+ monocytes are positioned near the CD14+ monocytes in cluster 4. Note: these are also known as CD16+ monocytes. 

```{r}
p14 <- FeaturePlot(pbmc, features = "FCGR3A") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p15 <- FeaturePlot(pbmc, features = "MS4A7") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
(p14 | p15) / p5
```

## Intermediate Monocytes

Lastly, it follows that between the CD14+ and FCGR3A+ monocytes are the intermediate monocytes, which [are characterized by](https://www.frontiersin.org/articles/10.3389/fimmu.2019.02035/full#B3) expression of CD14 and CD16, along with S100A8, CD74, HLA-DPB1, etc. 

```{r}
p16 <- FeaturePlot(pbmc, features = "HLA-DPB1") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p17 <- FeaturePlot(pbmc, features = "CD74") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p18 <- FeaturePlot(pbmc, features = "HLA-DRA") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
(p16 | p17 | p18) / p5
```


## B Cells

Expression of MS4A1 allows us to isolate the B cells in cluster 3.

```{r}
p19 <- FeaturePlot(pbmc, features = "MS4A1") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p19 / p5
```

## CD8+ T Cells

The canonical marker CD8A swiftly identifies our CD8+ T cells in cluster 2.

```{r}
p20 <- FeaturePlot(pbmc, features = "CD8A") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p20 / p5
```

## Natural Killer Cells

We can use NKG7 and GNLY to isolate the NK cells in cluster 5.

```{r}
p21 <- FeaturePlot(pbmc, features = "NKG7") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p22 <- FeaturePlot(pbmc, features = "GNLY") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
(p21 | p22) / p5
```

## Dendritic Cells

The dendritic cell group is defined by expression of FCER1A and CST3 in cluster 9.

```{r}
p23 <- FeaturePlot(pbmc, features = "FCER1A") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p24 <- FeaturePlot(pbmc, features = "CST3") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
(p23 | p24) / p5
```

## Platelets

The tiny platelet population of `r sum(pbmc$seurat_clusters == 10)` cells can be identified by its expression of PPBP in cluster 10.

```{r}
p25 <- FeaturePlot(pbmc, features = "PPBP") + 
       scale_color_gradientn(colors = paletteer_d("wesanderson::Zissou1")) + 
       theme_yehlab() + 
       NoLegend() + 
       theme(axis.title = element_blank())
p25 / p5
```

## Final Figure

Finally, we'll add cell labels to our original `Seurat` object and plot the results.

```{r}
pbmc$label <- case_when(pbmc$seurat_clusters == 0 ~ "Naive CD4+ T", 
                        pbmc$seurat_clusters == 1 ~ "CD14+ Monocyte", 
                        pbmc$seurat_clusters == 2 ~ "CD8+ T", 
                        pbmc$seurat_clusters == 3 ~ "B", 
                        pbmc$seurat_clusters == 4 ~ "FCGR3A+ Monocyte", 
                        pbmc$seurat_clusters == 5 ~ "NK", 
                        pbmc$seurat_clusters == 6 ~ "Memory CD4+ T", 
                        pbmc$seurat_clusters == 7 ~ "Th1", 
                        pbmc$seurat_clusters == 8 ~ "Intermediate Monocyte", 
                        pbmc$seurat_clusters == 9 ~ "DC", 
                        pbmc$seurat_clusters == 10 ~ "Platelet")
```

We visualize the final cells labels for our 11 clusters.  

```{r}
p26 <- DimPlot(pbmc, cols = paletteer_d("rcartocolor::Vivid"), group.by = "label") + 
       theme_yehlab() + 
       guides(color = guide_legend(nrow = 3, override.aes = list(size = 3))) + 
       labs(x = "Fit-SNE 1", y = "Fit-SNE 2", title = NULL)
p26
```

# Conclusions

SCISSORS automatically split a large CD4+ T cluster into naive, memory, and Th1 CD4+ T cells. It successfully separated a small dendritic cell cluster from the CD14+ monocytes it had originally been grouped with, and teased out the intermediate monocyte population nestled between the CD14+ and CD16+ monocyte clusters. Lastly, it identified a tiny platelet cluster that had been erroneously grouped with the CD16+ monocytes. The intermediate monocyte and Th1 cells were not annotated in [the original Satija Lab PBMC3k vignette](https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html). 

We used the PBMC3k dataset because of 1) its immediate availability to anyone wishing to replicate our results and 2) the validity of its annotations, which allowed us to be confident in the results from SCISSORS, which was able to carve out rare cell groups from larger, broader cell types. In this case, the dendritic cell cluster was composed of 39 cells, the Th1 cluster of 40 cells, and the platelet cluster of just 13 cells. However, SCISSORS isn't just useful for rare cell types: it also identified the intermediate monocytes, a cluster of 206 cells. We thus believe we can confidently say that SCISSORS has been shown to accurately and swiftly identify cell types, both common and rare, by considering the variance in gene expression within clusters and judging iterative reclustering using silhouette scores. We put forth that this approach is theoretically advantageous for identifying rare cell populations, rather than attempting to do so at the level of the entire dataset.

# Save Data & Figures

This part isn't really worth reading; it's just here to prove that all the figures were actually dynamically generated and saved upon knitting this document.

We'll create a quick convenience function to help us save the figures.

```{r}
saveSCISSORS <- function(plot = NULL, 
                         name = NULL, 
                         border = TRUE, 
                         pub.ready = FALSE) {
  if (is.null(plot) | is.null(name)) stop("You forgot some arguments.")
  if (pub.ready) {
    dir <- "~/Desktop/R/SCISSORS/vignettes/figures_pub/PBMC"
    if (!border) {
      plot <- plot + 
              theme(panel.border = element_blank(), 
                    axis.title = element_blank(), 
                    legend.position = "none")
    } else {
      plot <- plot + 
              theme(axis.title = element_blank(), 
                    legend.position = "none")
    }
    ggsave(filename = paste0(name, ".pdf"), 
           device = "pdf", 
           units = "in",
           path = dir, 
           height = 8, 
           width = 8) 
  } else {
    dir <- "~/Desktop/R/SCISSORS/vignettes/figures_supp/PBMC"
    ggsave(filename = paste0(name, ".pdf"), 
           device = "pdf", 
           units = "in",
           path = dir, 
           height = 8, 
           width = 8) 
  }
}
```

Lastly, we'll save the figures under `./vignettes/figures/`. 

```{r}
saveSCISSORS(plot = p0, name = "Seurat_Clusters", pub.ready = TRUE, border = FALSE)
saveSCISSORS(plot = p1, name = "Seurat_Clusters_FitSNE", pub.ready = TRUE, border = FALSE)
saveSCISSORS(plot = p2, name = "Clust0_Reclust", pub.ready = TRUE, border = FALSE)
saveSCISSORS(plot = p3, name = "Clust1_Reclust", pub.ready = TRUE, border = FALSE)
saveSCISSORS(plot = p4, name = "Clust2_Reclust", pub.ready = TRUE, border = FALSE)
saveSCISSORS(plot = p5, name = "SCISSORS_Clusters", pub.ready = TRUE, border = FALSE)
saveSCISSORS(plot = p6, name = "CD4T_IL7R")
saveSCISSORS(plot = p7, name = "CD4T_CCR7")
saveSCISSORS(plot = p8, name = "CD4T_S100A4")
saveSCISSORS(plot = p9, name = "TH1_IFIT1")
saveSCISSORS(plot = p10, name = "TH1_IFIT3")
saveSCISSORS(plot = p11, name = "TH1_IFI6")
saveSCISSORS(plot = p12, name = "Monocyte_CD14")
saveSCISSORS(plot = p13, name = "Monocyte_LYZ")
saveSCISSORS(plot = p14, name = "FCGR3A_Monocyte_FCGR3A")
saveSCISSORS(plot = p15, name = "FCGR3A_Monocyte_MS4A7")
saveSCISSORS(plot = p16, name = "Intermediate_Mono_HLADPB1")
saveSCISSORS(plot = p17, name = "Intermediate_Mono_CD74")
saveSCISSORS(plot = p18, name = "Intermediate_Mono_HLADRA")
saveSCISSORS(plot = p19, name = "B_MS4A1")
saveSCISSORS(plot = p20, name = "CD8T_CD8A")
saveSCISSORS(plot = p21, name = "NK_NKG7")
saveSCISSORS(plot = p22, name = "NK_GNLY")
saveSCISSORS(plot = p23, name = "DC_FCER1A")
saveSCISSORS(plot = p24, name = "DC_CST3")
saveSCISSORS(plot = p25, name = "Platelet_PPBP")
saveSCISSORS(plot = p26, name = "SCISSORS_final_labels", pub.ready = TRUE, border = FALSE)
```

And of course:

```{r}
sessionInfo()
```
